### *Који су REST принципи?*

1. Client - Server: 

Подразумева раздвајање одговорности између клијента и сервера. То доводи до портабилности клијентске стране која може да се извршава на било којој платформи независној од сервера. Такође серверске компоненте су простије за пројектовање јер је из њих изостављен део бриге о о+клијентској страни.
___

2. Uniform interface: 

Овде се мисли на стандардизован интерфејс за комуникацију између клијента и сервера. На Web2 у питању је HTTP протокол који је дефакто стандард за комуникацију на интернету. С обзиром да је у REST архитектури све везано за приступ ресурсима, сваки есурс мора да буде јединствено идентификован, тј. да једном за један ресурс постоји један и само један URL.
Такође је битно да сваки ресурс има своју `репрезентацију` приликом комуникације са клијентом што значи да ресурси који постоје на сервверу морају бити заштићени у одговарајућем формату који је доступан клијенту. То омогућавају _JSON DTO_ објекти. Они су репрезентација ресурса у одговарајућем формату.
Свака репрезентација ресурса мора да има довољно информација које је описују.
__Занимљиво__: клијент би требао да има само стартни URI сервера, док све следеће ресурсе одређује REST API кроз захтеве које упућује клијент апликација. То значи да кроз сваки одговор који се врати клијенту сервер шаље хиперлинкове ка следећим ресурсима коојима клијент може потенцијално да приступи. Овај приступ се назива: _Hypermedia as the Engine of Application State (HATEOAS)_

___

3. Stateless:

Ово најпростије значи да сервер __не__ памти контекст стања у коме се налази клијент. Из овог а произилази да сваки захтев мора да садржи све неопходне информације потребне за приступ ресурсу и не може се очекивати од сервер да "сам закључује нешто на основу претходних активности клијента".  Може се рећи такође да се сваки HTTP захтев од клијента ка серверу одвија изоловано - сваки захтев енкапсулира све потребне информације.

Одсуство *апликационог* стања доноси следеће погодности:

- боље скалирање при раду са великим бројем захтева
- једноставнија логика јер не постоји потреба за синхронизацијом апликационог стања
- једноставно одређивање који захтев треба кеширати, јер сам захтев са својим подацима дефинише да ли га треба кеширати

___

4. Cacheable:

Сваки захтев који стиген на сервер пролази кроз низ кеш меморија на различитим нивоима. Уколико неки кеш садржи одговор на дати захтев тај одговор ће бити враћен. Тиме се штеди на времену које би било потребно да сервер поново *израчунава* одговор. 

**GET** одговори би требали увек да буду *кешабилни*.

**POST** одговори стандардно не би требали да буду кешабилни. Уколико ипак постоји  потреба може експлицитно нагласити у заглављу захтева (`Expires` или `Cache-Control` заглавља)

**PUT** и **DELETE** одговори никако нису кешабилни.

___

5. Code on demand: (*Опционо*)

Постоји могућност да преко REST сервиса скине код и извршава га у форми аплета или скрипти.

Ово може да буде корисно за неке функционалности које је згодније извршавати на клијентској страни. Ту спадају безбедне али честе функционалности које немају утицај на стање ресурса који се налазе на серверу.

___

6. Layered system: 

REST веб сервиси имају слојевиту архитектуру. Код овакве архитектуре карактеристично је да је сваки слој свестан постојања само два слоја (*изнад* и *испод*) који са њим комуницирају. Такође је пракса да за свака два слоја постоји дефинисан интерфејс (репрезентација ресурса) преко кога та два слоја комуницирају.

Углавном је ситуација да постоји трослојна архитектура чији су слојеви одозго на доле:

1. презентациони слој (кориснички/клијентски интерфејс)
2. сервисни слој (пословна логика)
3. слој приступа подацима 

___

___

### Питање са интервјуа

Замислите ситуацију у којој је потребно извршити претрагу велике колекције записа под задатим условима. Број услова по којима клијент претражује је нпр. 30. Претрага сама по себи не мења стање ресурса (у бази на серверу) већ само довлачи назад резултате претраге. 
*Како би изгледао HTTP захтев / захтеви у овом случају?*
Ограничење је да се poштују REST принципи и улоге HTTP захтева (нпр. GET захтев не сме да мења стање; POST мора да мења стање)

___

[Извор](https://restfulapi.net/)
